:javascript
  // store list of prior_path markers
  var prior_path_lines = {};

  var snappedCoordinates = [];
  
  // draw run prior_path location on map
  function drawPriorPath(run_id, path_data) {
    console.log(path_data);
    if(!path_data || path_data.length == 0) {
      return;
    }

    renderLoadedPriorPath(run_id);

    // snap roads
    $.get('https://roads.googleapis.com/v1/snapToRoads', {
      interpolate: true,
      key: "#{ENV['GOOGLE_ROAD_API_KEY']}",
      path: path_data.join('|')
    }, function(data) {
      var snappedCoordinates = processSnapToRoadResponse(data);
      drawSnappedPolyline(run_id, snappedCoordinates);
    });
  }

  // Store snapped polyline returned by the snap-to-road service.
  function processSnapToRoadResponse(data) {
    var snappedCoordinates = [];
    for (var i = 0; i < data.snappedPoints.length; i++) {
      var latlng = new google.maps.LatLng(
          data.snappedPoints[i].location.latitude,
          data.snappedPoints[i].location.longitude);
      snappedCoordinates.push(latlng);
    }

    return snappedCoordinates;
  }

  // Draws the snapped polyline (after processing snap-to-road response).
  function drawSnappedPolyline(run_id, snappedCoordinates) {
    var run_path = prior_path_lines[run_id];
    if(!run_path) {
      run_path = new google.maps.Polyline({
        path: snappedCoordinates,
        strokeColor: 'black',
        strokeWeight: 3
      });
      run_path.setMap(map);

      prior_path_lines[run_id] = run_path;
    } else {
      var locCount = run_path.getPath().length;
      snappedCoordinates.forEach(function(latlng) {
        run_path.getPath().setAt(locCount - 1, latlng);
        locCount ++;
      });
    }
  }

  function renderLoadedPriorPath(run_id) {
    if(prior_path_lines[run_id]) {
      prior_path_lines[run_id].setMap(map);
    }
  }

  function removePriorPath(run_id) {
    if(prior_path_lines[run_id]) {
      prior_path_lines[run_id].setMap(null);
    }
  }